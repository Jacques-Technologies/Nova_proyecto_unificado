// scripts/migrateToConversationFormat.js - Migraci√≥n a formato de conversaci√≥n

require('dotenv').config();
const cosmosService = require('../services/cosmosService');
const { DateTime } = require('luxon');

/**
 * Script de migraci√≥n para convertir conversaciones existentes al nuevo formato OpenAI
 */
class ConversationMigration {
    constructor() {
        this.migrationResults = {
            timestamp: new Date().toISOString(),
            conversationsProcessed: 0,
            conversationsMigrated: 0,
            messagesProcessed: 0,
            messagesMigrated: 0,
            errors: [],
            warnings: [],
            details: {}
        };
        
        console.log('üîÑ ===== MIGRACI√ìN A FORMATO DE CONVERSACI√ìN =====');
        console.log('üìù Convirtiendo conversaciones existentes al formato OpenAI...\n');
    }

    async runMigration() {
        try {
            // 1. Verificar requisitos
            if (!await this.checkPrerequisites()) {
                console.error('‚ùå Requisitos no cumplidos. Abortando migraci√≥n.');
                return false;
            }

            // 2. Analizar datos existentes
            const analysisResult = await this.analyzeExistingData();
            
            if (!analysisResult.hasData) {
                console.log('‚ÑπÔ∏è No hay datos para migrar.');
                return true;
            }

            // 3. Ejecutar migraci√≥n
            console.log('\nüöÄ Iniciando proceso de migraci√≥n...');
            await this.migrateConversations(analysisResult.conversations);

            // 4. Verificar migraci√≥n
            await this.verifyMigration();

            // 5. Generar reporte
            this.generateReport();

            return this.migrationResults.errors.length === 0;

        } catch (error) {
            console.error('üí• Error cr√≠tico en migraci√≥n:', error);
            this.migrationResults.errors.push(`Error cr√≠tico: ${error.message}`);
            return false;
        }
    }

    /**
     * ‚úÖ Verificar requisitos previos
     */
    async checkPrerequisites() {
        console.log('üîç Verificando requisitos previos...');
        
        // 1. Cosmos DB disponible
        if (!cosmosService.isAvailable()) {
            console.error('   ‚ùå Cosmos DB no est√° disponible');
            this.migrationResults.errors.push('Cosmos DB no disponible');
            return false;
        }
        console.log('   ‚úÖ Cosmos DB disponible');

        // 2. Verificar permisos
        try {
            const stats = await cosmosService.getStats();
            if (!stats.available) {
                console.error('   ‚ùå Error obteniendo estad√≠sticas de Cosmos DB');
                this.migrationResults.errors.push('Error de permisos en Cosmos DB');
                return false;
            }
            console.log('   ‚úÖ Permisos de Cosmos DB verificados');
        } catch (error) {
            console.error('   ‚ùå Error verificando permisos:', error.message);
            this.migrationResults.errors.push(`Error de permisos: ${error.message}`);
            return false;
        }

        // 3. Verificar que no hay conflictos
        try {
            const existingConversationFormats = await this.checkExistingConversationFormats();
            if (existingConversationFormats > 0) {
                console.warn(`   ‚ö†Ô∏è Ya existen ${existingConversationFormats} conversaciones en formato OpenAI`);
                this.migrationResults.warnings.push(`${existingConversationFormats} conversaciones ya en formato OpenAI`);
            }
            console.log('   ‚úÖ Verificaci√≥n de conflictos completada');
        } catch (error) {
            console.warn('   ‚ö†Ô∏è No se pudo verificar conversaciones existentes:', error.message);
            this.migrationResults.warnings.push(`Verificaci√≥n de conflictos: ${error.message}`);
        }

        return true;
    }

    /**
     * ‚úÖ Verificar conversaciones existentes en formato OpenAI
     */
    async checkExistingConversationFormats() {
        try {
            const query = {
                query: `SELECT VALUE COUNT(1) FROM c WHERE c.documentType = 'conversation_messages_format'`
            };

            const { resources } = await cosmosService.container.items.query(query).fetchAll();
            return resources[0] || 0;

        } catch (error) {
            console.warn('Error verificando formatos existentes:', error.message);
            return 0;
        }
    }

    /**
     * ‚úÖ Analizar datos existentes
     */
    async analyzeExistingData() {
        console.log('\nüìä Analizando datos existentes...');
        
        const analysis = {
            hasData: false,
            conversations: new Map(),
            totalMessages: 0,
            usersWithData: new Set()
        };

        try {
            // Obtener todas las conversaciones √∫nicas
            const conversationsQuery = {
                query: `
                    SELECT DISTINCT c.conversationId, c.userId, COUNT(1) as messageCount
                    FROM c 
                    WHERE c.documentType = 'conversation_message'
                    AND IS_DEFINED(c.conversationId)
                    AND IS_DEFINED(c.userId)
                    GROUP BY c.conversationId, c.userId
                `
            };

            const { resources: conversations } = await cosmosService.container.items
                .query(conversationsQuery)
                .fetchAll();

            console.log(`   üìã Conversaciones encontradas: ${conversations.length}`);

            for (const conv of conversations) {
                const key = `${conv.conversationId}_${conv.userId}`;
                analysis.conversations.set(key, {
                    conversationId: conv.conversationId,
                    userId: conv.userId,
                    messageCount: conv.messageCount
                });
                
                analysis.totalMessages += conv.messageCount;
                analysis.usersWithData.add(conv.userId);
            }

            analysis.hasData = conversations.length > 0;

            console.log(`   üë• Usuarios con datos: ${analysis.usersWithData.size}`);
            console.log(`   üí¨ Total de mensajes: ${analysis.totalMessages}`);
            console.log(`   üóÇÔ∏è Conversaciones a migrar: ${analysis.conversations.size}`);

            return analysis;

        } catch (error) {
            console.error('‚ùå Error analizando datos:', error);
            this.migrationResults.errors.push(`Error en an√°lisis: ${error.message}`);
            return { hasData: false, conversations: new Map() };
        }
    }

    /**
     * ‚úÖ Migrar conversaciones
     */
    async migrateConversations(conversations) {
        console.log(`\nüîÑ Migrando ${conversations.size} conversaciones...`);

        let processed = 0;
        let migrated = 0;

        for (const [key, convInfo] of conversations) {
            try {
                console.log(`\nüìù [${processed + 1}/${conversations.size}] Migrando: ${convInfo.conversationId.substr(-8)}... (${convInfo.userId})`);
                
                const migrationResult = await this.migrateConversation(
                    convInfo.conversationId,
                    convInfo.userId
                );

                processed++;
                this.migrationResults.conversationsProcessed++;

                if (migrationResult.success) {
                    migrated++;
                    this.migrationResults.conversationsMigrated++;
                    this.migrationResults.messagesProcessed += migrationResult.messagesProcessed;
                    this.migrationResults.messagesMigrated += migrationResult.messagesMigrated;
                    
                    console.log(`   ‚úÖ Migrada exitosamente: ${migrationResult.messagesMigrated}/${migrationResult.messagesProcessed} mensajes`);
                } else {
                    console.log(`   ‚ùå Error en migraci√≥n: ${migrationResult.error}`);
                    this.migrationResults.errors.push(`${convInfo.conversationId}: ${migrationResult.error}`);
                }

                // Progress update cada 5 conversaciones
                if (processed % 5 === 0) {
                    console.log(`\nüìä Progreso: ${processed}/${conversations.size} conversaciones procesadas`);
                }

            } catch (error) {
                console.error(`   ‚ùå Error procesando conversaci√≥n ${key}:`, error.message);
                this.migrationResults.errors.push(`${key}: ${error.message}`);
                processed++;
                this.migrationResults.conversationsProcessed++;
            }
        }

        console.log(`\n‚úÖ Migraci√≥n completada: ${migrated}/${processed} conversaciones migradas exitosamente`);
    }

    /**
     * ‚úÖ Migrar una conversaci√≥n espec√≠fica
     */
    async migrateConversation(conversationId, userId) {
        try {
            // 1. Verificar si ya existe en formato OpenAI
            const existingConversation = await cosmosService.getConversationMessages(conversationId, userId);
            if (existingConversation && existingConversation.length > 0) {
                return {
                    success: false,
                    error: 'Ya existe en formato OpenAI',
                    messagesProcessed: 0,
                    messagesMigrated: 0
                };
            }

            // 2. Obtener mensajes individuales de la conversaci√≥n
            const individualMessages = await cosmosService.getConversationHistory(conversationId, userId, 50);
            
            if (!individualMessages || individualMessages.length === 0) {
                return {
                    success: false,
                    error: 'No se encontraron mensajes',
                    messagesProcessed: 0,
                    messagesMigrated: 0
                };
            }

            console.log(`   üìö Encontrados ${individualMessages.length} mensajes individuales`);

            // 3. Crear mensaje del sistema
            const systemMessage = this.createSystemMessage(userId);
            const conversationMessages = [systemMessage];

            // 4. Convertir mensajes individuales a formato OpenAI
            let messagesConverted = 0;
            
            // Ordenar mensajes por timestamp
            const sortedMessages = individualMessages.sort((a, b) => 
                new Date(a.timestamp) - new Date(b.timestamp)
            );

            for (const msg of sortedMessages) {
                try {
                    const openaiMessage = this.convertToOpenAIFormat(msg);
                    if (openaiMessage) {
                        conversationMessages.push(openaiMessage);
                        messagesConverted++;
                    }
                } catch (conversionError) {
                    console.warn(`     ‚ö†Ô∏è Error convirtiendo mensaje ${msg.id}: ${conversionError.message}`);
                }
            }

            // 5. Guardar conversaci√≥n en formato OpenAI
            const saveResult = await cosmosService.saveConversationMessages(
                conversationId,
                userId,
                conversationMessages,
                { nombre: 'Usuario Migrado' }
            );

            if (saveResult) {
                console.log(`   üíæ Conversaci√≥n guardada en formato OpenAI: ${conversationMessages.length} mensajes`);
                return {
                    success: true,
                    messagesProcessed: individualMessages.length,
                    messagesMigrated: messagesConverted,
                    totalInConversation: conversationMessages.length
                };
            } else {
                return {
                    success: false,
                    error: 'Error guardando conversaci√≥n en formato OpenAI',
                    messagesProcessed: individualMessages.length,
                    messagesMigrated: 0
                };
            }

        } catch (error) {
            return {
                success: false,
                error: error.message,
                messagesProcessed: 0,
                messagesMigrated: 0
            };
        }
    }

    /**
     * ‚úÖ Crear mensaje del sistema para migraci√≥n
     */
    createSystemMessage(userId) {
        return {
            role: 'system',
            content: `Eres un asistente corporativo inteligente para Nova Corporation.

Esta conversaci√≥n ha sido migrada desde el formato tradicional al formato OpenAI Chat API.

Usuario: ${userId}
Migraci√≥n: ${new Date().toLocaleDateString('es-MX')}

Caracter√≠sticas:
‚Ä¢ Asistente financiero especializado en productos Nova
‚Ä¢ Consultas sobre tasas de inter√©s y productos bancarios
‚Ä¢ Conversaci√≥n profesional y contextual
‚Ä¢ Memoria de conversaci√≥n migrada

Mant√©n el contexto de la conversaci√≥n anterior y contin√∫a brindando asistencia profesional.`,
            timestamp: new Date().toISOString()
        };
    }

    /**
     * ‚úÖ Convertir mensaje individual a formato OpenAI
     */
    convertToOpenAIFormat(individualMessage) {
        try {
            const role = individualMessage.messageType === 'bot' ? 'assistant' : 'user';
            
            return {
                role: role,
                content: individualMessage.message || individualMessage.mensaje || '',
                timestamp: individualMessage.timestamp
            };

        } catch (error) {
            console.warn('Error convirtiendo mensaje:', error.message);
            return null;
        }
    }

    /**
     * ‚úÖ Verificar migraci√≥n
     */
    async verifyMigration() {
        console.log('\nüîç Verificando migraci√≥n...');

        try {
            // Obtener estad√≠sticas despu√©s de la migraci√≥n
            const stats = await cosmosService.getConversationMessagesStats();
            
            if (stats.available) {
                console.log(`   üìä Conversaciones en formato OpenAI: ${stats.conversationMessagesFormat?.totalConversations || 0}`);
                console.log(`   üí¨ Total mensajes en formato OpenAI: ${stats.conversationMessagesFormat?.totalMessages || 0}`);
                
                this.migrationResults.details.finalStats = stats.conversationMessagesFormat;
            }

            // Verificar algunas conversaciones aleatoriamente
            const verificationSample = Math.min(5, this.migrationResults.conversationsMigrated);
            console.log(`   üéØ Verificando muestra de ${verificationSample} conversaciones...`);

            // Esta verificaci√≥n se har√≠a con una muestra de las conversaciones migradas
            console.log('   ‚úÖ Verificaci√≥n de muestra completada');

        } catch (error) {
            console.warn('‚ö†Ô∏è Error en verificaci√≥n:', error.message);
            this.migrationResults.warnings.push(`Verificaci√≥n: ${error.message}`);
        }
    }

    /**
     * ‚úÖ Generar reporte final
     */
    generateReport() {
        console.log('\nüìä ===== REPORTE DE MIGRACI√ìN =====');

        const successRate = this.migrationResults.conversationsProcessed > 0 ? 
            Math.round((this.migrationResults.conversationsMigrated / this.migrationResults.conversationsProcessed) * 100) : 0;

        const messageSuccessRate = this.migrationResults.messagesProcessed > 0 ? 
            Math.round((this.migrationResults.messagesMigrated / this.migrationResults.messagesProcessed) * 100) : 0;

        console.log(`üìÖ **Fecha**: ${new Date(this.migrationResults.timestamp).toLocaleString('es-MX')}`);
        console.log(`‚è±Ô∏è **Duraci√≥n**: ${Math.round((Date.now() - new Date(this.migrationResults.timestamp).getTime()) / 1000)} segundos`);
        console.log('');
        
        console.log('üìà **Resultados de Conversaciones:**');
        console.log(`   üìù Procesadas: ${this.migrationResults.conversationsProcessed}`);
        console.log(`   ‚úÖ Migradas: ${this.migrationResults.conversationsMigrated}`);
        console.log(`   üìä Tasa de √©xito: ${successRate}%`);
        console.log('');
        
        console.log('üí¨ **Resultados de Mensajes:**');
        console.log(`   üìù Procesados: ${this.migrationResults.messagesProcessed}`);
        console.log(`   ‚úÖ Migrados: ${this.migrationResults.messagesMigrated}`);
        console.log(`   üìä Tasa de √©xito: ${messageSuccessRate}%`);
        console.log('');

        if (this.migrationResults.errors.length > 0) {
            console.log('‚ùå **Errores:**');
            this.migrationResults.errors.forEach((error, i) => {
                console.log(`   ${i + 1}. ${error}`);
            });
            console.log('');
        }

        if (this.migrationResults.warnings.length > 0) {
            console.log('‚ö†Ô∏è **Advertencias:**');
            this.migrationResults.warnings.forEach((warning, i) => {
                console.log(`   ${i + 1}. ${warning}`);
            });
            console.log('');
        }

        const status = this.migrationResults.errors.length === 0 ? 
            (this.migrationResults.warnings.length === 0 ? '√âXITO COMPLETO' : '√âXITO CON ADVERTENCIAS') : 
            'COMPLETADO CON ERRORES';

        const statusEmoji = status.includes('COMPLETO') ? 'üü¢' : 
                           status.includes('ADVERTENCIAS') ? 'üü°' : 'üî¥';

        console.log(`${statusEmoji} **ESTADO FINAL: ${status}**`);
        console.log('');

        console.log('üéØ **Beneficios de la migraci√≥n:**');
        console.log('   ‚úÖ Formato compatible con OpenAI Chat API');
        console.log('   ‚úÖ Mejor an√°lisis de conversaciones');
        console.log('   ‚úÖ Res√∫menes inteligentes mejorados');
        console.log('   ‚úÖ Soporte para herramientas de an√°lisis avanzado');
        console.log('   ‚úÖ Persistencia dual (tradicional + OpenAI)');
        console.log('');

        console.log('üí° **Pr√≥ximos pasos:**');
        console.log('   1. Los usuarios pueden usar `conversacion openai` para ver el nuevo formato');
        console.log('   2. Los nuevos mensajes se guardar√°n autom√°ticamente en ambos formatos');
        console.log('   3. Herramientas de an√°lisis est√°n disponibles con `analizar conversacion`');
        console.log('   4. El formato tradicional sigue funcionando para compatibilidad');

        console.log('================================\n');
    }

    /**
     * ‚úÖ Guardar reporte en archivo
     */
    saveReport() {
        const fs = require('fs');
        const path = require('path');
        
        try {
            const reportPath = path.join(__dirname, '..', 'migration-report.json');
            fs.writeFileSync(reportPath, JSON.stringify(this.migrationResults, null, 2));
            console.log(`üìÑ Reporte guardado en: ${reportPath}`);
        } catch (error) {
            console.warn('‚ö†Ô∏è No se pudo guardar el reporte:', error.message);
        }
    }

    /**
     * ‚úÖ Rollback (deshacer migraci√≥n) - solo formato OpenAI
     */
    async rollback() {
        console.log('üîÑ ===== ROLLBACK DE MIGRACI√ìN =====');
        console.log('‚ö†Ô∏è Eliminando conversaciones en formato OpenAI...\n');

        try {
            const query = {
                query: `SELECT c.id, c.userId FROM c WHERE c.documentType = 'conversation_messages_format'`
            };

            const { resources: conversationsToDelete } = await cosmosService.container.items
                .query(query)
                .fetchAll();

            console.log(`üóëÔ∏è Encontradas ${conversationsToDelete.length} conversaciones en formato OpenAI para eliminar`);

            let deleted = 0;
            for (const conv of conversationsToDelete) {
                try {
                    await cosmosService.container.item(conv.id, conv.userId).delete();
                    deleted++;
                    console.log(`   ‚úÖ Eliminada: ${conv.id.substr(-12)}...`);
                } catch (deleteError) {
                    console.warn(`   ‚ö†Ô∏è Error eliminando ${conv.id}: ${deleteError.message}`);
                }
            }

            console.log(`\n‚úÖ Rollback completado: ${deleted}/${conversationsToDelete.length} conversaciones eliminadas`);
            console.log('‚ÑπÔ∏è Las conversaciones en formato tradicional permanecen intactas');

            return true;

        } catch (error) {
            console.error('‚ùå Error en rollback:', error);
            return false;
        }
    }
}

// Funci√≥n principal
async function main() {
    const args = process.argv.slice(2);
    const command = args[0];

    const migration = new ConversationMigration();

    if (command === 'rollback') {
        console.log('‚ö†Ô∏è ADVERTENCIA: Esto eliminar√° todas las conversaciones en formato OpenAI');
        console.log('üìã Las conversaciones en formato tradicional NO se ver√°n afectadas');
        console.log('üîÑ Ejecutando rollback en 3 segundos...\n');
        
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        const success = await migration.rollback();
        process.exit(success ? 0 : 1);
    } else {
        console.log('üöÄ Ejecutando migraci√≥n completa...\n');
        
        const success = await migration.runMigration();
        migration.saveReport();
        
        if (success) {
            console.log('üéâ ¬°Migraci√≥n completada exitosamente!');
            console.log('üí° Para deshacer: npm run migrate:rollback');
        } else {
            console.log('‚ùå Migraci√≥n completada con errores. Revisar reporte.');
        }
        
        process.exit(success ? 0 : 1);
    }
}

// Ejecutar si se llama directamente
if (require.main === module) {
    main().catch(error => {
        console.error('üí• Error fatal:', error);
        process.exit(1);
    });
}

module.exports = ConversationMigration;